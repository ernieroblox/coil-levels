data structure
Rows Dictionary<(int,int),Seg> for every square what seg owns it.
-seg going a,b,c
    it doesn't own c (since that's the start of the next seg)
        -except for the end square
Hits Dictionary<(int,int),List<Seg>) all the segs that hit sq

Seg
    start
    index - why do we need this? Isn't this identical to segs.IndexOf(seg)?
        how long does that take to calculate?
        when we insert a seg it's annoying that we have to increment all downstream indexes
        even if we use indexof, how would it even be possible to increment them?
1. go til you can't
    limit of path length? but nice to go far.
2. add a kink
    we have normal ones and long ones (where the return continues the next seg)
3. parameterize everything and find the highest density:
    v1: just control the order we try tweaks
        start ordering
        len1 ordering - max is better
        len2 ordering - long is better
    problem: super long len1/len2 can really inefficiently waste time trying tons of obviously non-legal parts. no meta framework for this
    v2: examine multiple/all tweaks available and pick the "biggest" / "best" one - more work but gets more density
what are we trying to do? get max density? or is there a max reasonable? can get ~67% now which is visually nice. Wonder what 80% is like. But more may be bad at some point.

Status:
    basic board generation done.
    what about a UI for board generation and testing?
    nah just static files is fine at least.
    
Problems;
    can't do super long tweaks.
        because of hooks.
        how to detect them in general?
        down to N, over M, back up- if this fails, then
            down to N-1, over M, back up is also likely to fail
            what if we started going out as far as possible, but didn't accept it til the last one?
        
using System;
using System.Linq;
using System.Collections.Generic;
using System.Diagnostics;

using static coil.Util;
using static coil.Debug;

namespace coil
{
    class Program
    {
        static void Main(string[] args)
        {
            var ii = 21;
            var mm = 22;
            var x = 60;
            var y = 43;
            //target = "rand99";
            //re-validate the board at every step
            var debug = false;

            var stem = $"../../../output/{x}x{y}";

            if (!System.IO.Directory.Exists(stem))
            {
                System.IO.Directory.CreateDirectory($"{stem}");
            }
            if (!System.IO.Directory.Exists($"../../../tweaks/"))
            {
                System.IO.Directory.CreateDirectory($"../../../tweaks/");
            }

            while (ii < mm)
            {
                var runCount = 0;
                var lc2hash = new Dictionary<LevelConfiguration, string>();
                //var ws = new InitialWanderSetup(steplimit:2, startPoint:(1,1));
                var ws = new InitialWanderSetup();
                //not used

                //problems with the whole validation thing: 
                //hmm, there should be no randomness in tweak generation.

                //segpickers unused
                var sp = new BackwardSegPicker();

                foreach (var rule in new List<bool>() { true})
                {
                    
                    //warning: pickers are stateful (through globalrand)
                    var cs = new OptimizationSetup();
                    cs.UseSpaceFillingIndexes = rule;
                    foreach (var picker in TweakPickers.GetPickers())
                    {
                        //if (picker.Name != "equal-remainders" )
                        //{
                        //    continue;
                        //}

                        var rnd = new System.Random(ii);
                        var lc = new LevelConfiguration(picker, sp, cs, ws);
                        runCount++;
                        var log = new Log(lc);
                        var counter = new Counter(lc);
                        var l = new Level(lc, log, x, y, rnd, debug, ii, counter);

                        l.InitialWander();
                        if (lc.OptimizationSetup.UseSpaceFillingIndexes)
                        {
                            l.RedoAllIndexesSpaceFillndexes();
                        }

                        var st = Stopwatch.StartNew();
                        l.RepeatedlyTweak(true, 1000);
                        counter.Show();
                        var rep = Report(l, st.Elapsed);

                        if (runCount == 0)
                        {
                            Util.SaveEmpty(l, $"{stem}/e-{ii}.png");
                            Util.SaveWithPath(l, $"{stem}/p-{ii}.png");
                        }
                        //leave this in for one final sense check.
                        DoDebug(l, false);
                        log.Info(rep);
                        Util.SaveEmpty(l, $"{stem}/e-{ii}-{lc.GetStr()}.png", subtitle: rep, quiet: true);
                        Util.SaveWithPath(l, $"{stem}/p-{ii}-{lc.GetStr()}.png", subtitle: rep, quiet: true);

                        //lc2hash[lc] = l.GetHash();
                        var step = l.TotalLength();
                        while (step > 100)
                        {
                            step = step / 2;
                            var tpfn = $"{stem}/ap-{ii}-{step}-{lc.GetStr()}.png";
                            SaveAverageOnPath(l, step, tpfn, quiet:false);
                            var arrowfn = $"{stem}/arrow-{ii}-{step}-{lc.GetStr()}.png";
                            SaveAverageOnPathWithArrows(l, step, arrowfn, quiet: false);
                            var tefn = $"{stem}/ae-{ii}-{step}-{lc.GetStr()}.png";
                            SaveAverageOnEmpty(l, step, tefn, quiet: false);
                            var arrowefn = $"{stem}/arrow-empty-{ii}-{step}-{lc.GetStr()}.png";
                            SaveAverageOnEmptyWithArrows(l, step, arrowefn, quiet: false);
                        }
                    }
                }
                // TODO: compare hashes generated by all the cache usage combinations tested above and alert if different.
                //foreach (var k in lc2hash.Keys)
                //{
                //    WL($"{k} = {lc2hash[k].Length} {lc2hash[k]}");
                //}
                ii++;
            }
        }
    }
}

using System;
using System.Linq;
using System.Collections.Generic;
using System.Diagnostics;

using static coil.Util;
using static coil.Debug;

namespace coil
{
    class Program
    {
        static void Main(string[] args)
        {
            var ii = 21;
            var mm = 22;
            var x = 26;
            var y = 20;
            var target = "rand99-sizelim5";
            //target = "rand99";
            //re-validate the board at every step
            var debug = false;

            var stem = $"../../../output/{x}x{y}";

            if (!System.IO.Directory.Exists(stem))
            {
                System.IO.Directory.CreateDirectory($"{stem}");
            }
            if (!System.IO.Directory.Exists($"../../../tweaks/"))
            {
                System.IO.Directory.CreateDirectory($"../../../tweaks/");
            }

            while (ii < mm)
            {
                var runCount = 0;
                var lc2hash = new Dictionary<LevelConfiguration, string>();
                //var ws = new InitialWanderSetup(steplimit:2, startPoint:(1,1));
                var ws = new InitialWanderSetup();
                //not used

                //problems with the whole validation thing: 
                //hmm, there should be no randomness in tweak generation.

                //segpickers unused
                var sp = new BackwardSegPicker();

                foreach (var rule in new List<bool>() { true, false })
                {
                    
                    //warning: pickers are stateful (through globalrand)
                    var cs = new OptimizationSetup();
                    cs.UseSTVCache = true;
                    cs.UseSpaceFillingIndexes = rule;
                    foreach (var picker in TweakPickers.GetPickers())
                    {
                        if (false && picker.Name != "fifth-rand10")
                        {
                            continue;
                        }
                        if (picker.Name!= "first5-sizelim5")
                        {
                            continue;
                        }

                        var rnd = new System.Random(ii);
                        var lc = new LevelConfiguration(picker, sp, cs, ws);
                        runCount++;
                        var log = new Log(lc);
                        var l = new Level(lc, log, x, y, rnd, debug, ii);

                        l.InitialWander();
                        if (lc.OptimizationSetup.UseSpaceFillingIndexes)
                        {
                            l.RedoAllIndexesSpaceFillndexes();
                        }

                        var st = Stopwatch.StartNew();
                        l.RepeatedlyTweak(true, 300000);
                        var rep = Report(l, st.Elapsed);

                        if (runCount == 0)
                        {
                            Util.SaveEmpty(l, $"{stem}/e-{ii}.png");
                            Util.SaveWithPath(l, $"{stem}/p-{ii}.png");
                        }
                        //leave this in for one final sense check.
                        DoDebug(l, false);
                        log.Info(rep);
                        Util.SaveEmpty(l, $"{stem}/e-{ii}-{lc.GetStr()}.png", subtitle: rep, quiet: true);
                        Util.SaveWithPath(l, $"{stem}/p-{ii}-{lc.GetStr()}.png", subtitle: rep, quiet: true);

                        lc2hash[lc] = l.GetHash();
                    }
                }
                // TODO: compare hashes generated by all the cache usage combinations tested above and alert if different.
                //foreach (var k in lc2hash.Keys)
                //{
                //    WL($"{k} = {lc2hash[k].Length} {lc2hash[k]}");
                //}
                ii++;
            }
        }
    }
}
